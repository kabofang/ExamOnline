#include "dh.h"
#include "msgdispatcher.h"
#include "CSecure.h"
#include "CDes.h"
#include "CRsa.h"
#include "tempvar.h"
#include "sha.h"

HWND CMSGDISPATCHER::h_dlgtest = NULL;
extern char sa[MAX],sb[MAX],p[MAX],g[MAX],au[MAX];
extern int a;

//定义消息分发函数，实现对于接收到的任意消息的处理
int CMSGDISPATCHER::do_response(ULONG saddr,int subtype,char *pdata,int len)
{
	bool rtnflg = false;
	char *pnew = NULL;
	if (len < 1)
		return true;
	
	switch(subtype)
	{
	case MSG_TEST_LOAD:
		{
			pnew = new char[len];
			memset(pnew,0,len);
			strcpy(pnew,pdata);
			PostMessage(CMSGDISPATCHER::h_dlgtest,WM_LOADTEST,(WPARAM)pnew,NULL);
		}
		break;
	case MSG_TEST_COMMIT:
		{
		CString str_score;
		str_score.Format("您的得分为%d",*(int *)pdata);
		AfxMessageBox(str_score);
		}
		break;
#ifdef NEG_ENCRYPT
	case MSG_REQCERT:
		//char* pCert = new char[len];
		char* pPlain;
		NegKey->Decrypt(len, pdata, &pPlain);				//使用CA公钥将证书解密
		Cert = new CCert;
		memmove(Cert, pPlain, sizeof(CCert));
		if (strcmp(Cert->GetOwner(), "ExamOnline Server") || strcmp(Cert->GetLusser(), "ExamOnline CA") )
			return CERTFAIL;								//验证证书内容中的owner是否为考试系统服务器，颁发者是否是自定义的CA
		if (!strcmp(Cert->GetHash(), "DIY_SHA")) {			//查看消息摘要算法，根据消息摘要算法的不同，进行不同的操作
			unsigned char pHashValue[64];					//这里只有自定义sha1算法，所以直接计算hash值
			memmove(pHashValue, Cert->GetHashValue(), 64);
			memset(Cert->GetHashValue(), 0, 64);
			SHA1_CONTEXT ctx;
			sha1_init(&ctx);
			sha1_write(&ctx, (unsigned char*)Cert, 3 * DATALEN + KEYLEN + HASHLEN + sizeof(int));
			sha1_final(&ctx);
			for (int i = 0; i < 64; i++)
				if (ctx.buf[i] != pHashValue[i])			//把计算出的hash值与原证书中的hash值对比，以验证证书的完整性
					return CERTFAIL;
			delete (CRsa*)NegKey;
			NegKey = new CRsa;								//证书合法且完整，从中取出公钥，生成Rsa对象
			NegKey->Init(Cert->GetPubKey(), Cert->GetKeylen());
		}
		else
			return CERTFAIL;
		break;
#endif
	case MSG_KEY_NEGOTIATE:
#ifdef NEG_ENCRYPT
		int Keylen = NegKey->GetKeylen();
		char* pplain;
		NegKey->Decrypt(Keylen, pdata, &pplain);//RSA解密协商信息
		delete NegKey;//协商结束释放资源
		memmove(sb, pplain,MAX);
		delete pplain;
#else
		memmove(sb, pdata, MAX);
#endif
		getkey(a,sb,p,g,au);

#ifdef MSG_ENCRYPT
		Key = new CDes;
		Key->Init(au, MAX);//用协商好的DES密钥创建DES对象
#endif
		break;
	}
	return rtnflg;
}

//消息接收处理分发入口函数
int msgdispatcher(void *pobj,MSGHEAD *phead,char *pdata,char **presdata)
{
	int rtnflg = true;
	if (phead == NULL)
		return false;
	
#ifdef MSG_ENCRYPT
	char* plainText;
	if (phead->m_subtype != MSG_KEY_NEGOTIATE&& phead->m_subtype != MSG_REQCERT && phead->m_datalen)
	{
		Key->Decrypt(phead->m_datalen, pdata, &plainText);//DES解密数据
		memcpy(pdata, plainText, phead->m_datalen);
		delete plainText;
	}
#endif

	SOCKADDR_IN *paddr = (SOCKADDR_IN *)pobj;
	switch(phead->m_type)
	{
	case MSG_RESPONSE_SUCCESS://接收到成功的响应
		rtnflg = CMSGDISPATCHER::do_response(paddr->sin_addr.S_un.S_addr,phead->m_subtype,pdata,phead->m_datalen);
		break;
	case MSG_RESPONSE_FAIL://接收到失败的响应
		break;
	}

	return rtnflg;
}